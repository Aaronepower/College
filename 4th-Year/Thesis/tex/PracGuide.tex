\section{Introduction}
In this section, the focus will be on constructing \acro{HTML} from Jade, an existing templating language. This example will not cover every feature, or edge case, but will show concisely how a developer would build a parser, and how parsing works in practical terms. The Jade that will be converted is the Figure~\ref{fig:html}. This will be converted to the code shown in Figure~\ref{fig:html}, except without the whitespace(except within text), and newlines. The ``->'' character represents the tab character. While Jade can handle tabs or space characters, for simplicity this will focus purely with the tab character. Jade is whitespace sensitive meaning if the the leading whitespace(The whitespace at the start of a line) is more than the previous line, the element on the line is the child of the element from the previous line. The ``.'' syntax as seen in Figure ~\ref{fig:html}, is shorthand for adding a class to the element so \verb|p.article| would become \verb|<p class="article"></p>|.
\newpage
\section{Definitions}
For this example there will be two main structs(A struct is a basic data structure with fields containing data). The \textit{``parser''} struct, and \textit{``Element''} struct. Where the parser struct represents the parser itself, and containing methods related to handling the input. And output of the program. Code samples containing method definitions are shortened to signatures for brevity.
\begin{figure}[!hbtp]
    \Large{\textbf{Jade}}\normalsize
    \begin{verbatim}
        html
        ->body
        ->->p.article Hello World!
    \end{verbatim}
    \Large{\textbf{\acro{HTML}}}\normalsize
    \begin{minted}{html}
        <html>
            <body>
                <p class="article">
                    Hello World!
                </p>
            </body>
        </html>
    \end{minted}
    \caption{Sample Jade code, and the \acro{HTML} code generated from it.}
    \label{fig:html}
\end{figure}
\newpage
\subsection{Element}
The \textit{``Element''} struct defines an individual element within both the \acro{AST} and \acro{HTML}. Markup languages such as \acro{HTML} can usually be translated directly from \acro{AST} representation to code, due to their already present parent-child relation. Features that don't directly translate, such as variables or keywords(extends, includes). It'd be better to have a \textit{``Node''} struct, that could contain the either the element struct, or another defining rules of the other features. Both structs also implement the \textit{``Debug''} trait to allow them to be easily printed to the console.

\subsubsection{Element Properties}
\begin{itemize}
    \item[\textbf{tag}] The html tag of the element. eg. \textit{html, body, h1, p}
    \item[\textbf{indentation}] In Jade leading whitespace defines the hierarchy of the elements. So it is important to keep track of the whitespace.
    \item[\textbf{attributes}] A Key-Value pairing of the attributes.
    \item[\textbf{classes}] The class attribute is the only html attribute that accepts multiple values, This makes it unsuitable for the attributes property.
    \item[\textbf{text}] The plain text within the element.
    \item[\textbf{children}] The child elements of the element.
\end{itemize}
\subsubsection{Element Functions}
\begin{itemize}
    \item[\textbf{new}] Creates, and returns an empty Element.
    \item[\textbf{html}] Returns a \textit{String} of html code, based on it's properties. This method is also recursive. Calling each of it's children's \textbf{html} methods.
    \item[\textbf{get \& set}] The get, and set methods for all the properties above.
    \item[\textbf{add \& remove}] For properties containing multiple values like classes, children, and attributes. These would also have methods for pushing, and removing an individual value from them.
\end{itemize}

\begin{figure}[!hbtp]
    \small
    \setstretch{1.0}
    \begin{minted}{rust}
      #[derive(Debug)]
      struct Element {
        tag: String,
        indentation: u8,
        classes: Vec<String>,
        attributes: HashMap<String, String>,
        text: String,
        children: Vec<Element>,
      }

      impl Element {
        fn new() -> Self {...}
        fn html(&self) -> String {...}
        fn get_tag(&self) -> String {...}
        fn set_tag(&mut self, tag: String) {...}
        fn get_indentation(&self) -> u8 {...}
        fn set_indentation(&mut self, indentation: u8) {...}
        fn get_classes(&self) -> Vec<String> {...}
        fn set_classes(&mut self) {...}
        fn get_attributes(&self) -> HashMap<String, String> {...}
        fn set_attributes(&mut self) {...}
        fn get_text(&self) -> String {...}
        fn set_text(&mut self, text: String) {...}
        fn get_children(&self) -> Element {...}
        fn set_children(&mut self) {...}
        fn add_child(&mut self, child: Element) {...}
        fn add_attribute(&mut self, key: String, value: String) {...}
        fn add_class(&mut self, class: String) {...}
        fn remove_child(&mut self, child: Element) {...}
        fn remove_attribute(&mut self, key: String) {...}
        fn remove_class(&mut self, class: String) {...}
      }
    \end{minted}
    \caption{Element code}
\end{figure}

\subsection{Parser}
The parser struct represents the Parser itself. All logic with regards to moving through the input given by the user is either handled within this struct, or through calling methods on this struct.

\subsubsection{Parser Properties}
\begin{itemize}
    \item[\textbf{input}] The source code given by the user. Usually the contents of a file.
    \item[\textbf{position}] The parsers position within the input. 
    \item[\textbf{output}] A vector of the elements parsed.
\end{itemize}

\subsubsection{Parser Functions}
\begin{itemize}
    
    \item[\textbf{new}] Creates, and returns a new parser containing the source passed in.
    
    \item[\textbf{take}] Returns an Option either containing the next character, and removes it from the input. Or None indicating EOF(End Of File).
    
    \item[\textbf{eof}] Checks if we've reached the end of the source.
    
    \item[\textbf{peek}] Returns an Option either containing the next character, but doesn't remove it from the input. Or None indicating EOF.

    \item[\textbf{take\_spaces}] Removes characters until the character isn't whitespace (space, tab, newline, carriage return), and returns how many characters were removed.
    \newpage
    \item[\textbf{take\_until}] Takes, and remove characters from the source until it reaches the character passed as a parameter. It then returns a Result either containing a String of all the characters taken excluding the character passed, or a ParseError indicating that something failed while taking the characters. eg. EOF.

    \item[\textbf{peek\_until}] Takes, but doesn't remove characters from the source until it reaches the character passed as a parameter. Then returns a Result either containing a String of all the characters taken excluding the character passed, or a ParseError indicating that something failed while taking the characters. eg. EOF.
    
    \item[\textbf{take\_while}] Takes, and removes characters, while the function passed evaluates to false. The function passed in, is passed a char, which is the the latest character in the stream.
    
    \item[\textbf{get \& set}] The get, and set methods for all the properties above.
\end{itemize}

\begin{figure}[!hbtp]
    \small
    \setstretch{1.0}
  \begin{minted}{rust}
    #[derive(Debug)]
    enum ParseError {
      EOF,
      EncodingError,
    }
    #[derive(Debug)]
    struct Parser {
      input: String,
      position: usize,
      output: Vec<Element>
    }
    impl Parser {
      fn new(source: String) -> Self {...}
      fn take(&mut self) -> Option<char> {...}
      fn peek(&mut self) -> Option<char> {...}
      fn eof(&self) -> bool {...}
      fn take_spaces(&mut self) -> u8 {...}
      fn take_until(&mut self, character: char) 
      -> Result<String, ParseError> {...}
      fn peek_until(&mut self, character: char) 
      -> Result<String, ParseError> {...}
      fn take_while<F>(&mut self, condition: F) 
      -> Result<String, ParseError> 
        where F : Fn(char) -> bool {...}
      fn get_input(&self) -> String {...}
      fn set_input(&mut self, input: String) {...}
      fn get_position(&self) -> usize {...}
      fn set_position(&mut self, position: usize) {...}
      fn get_output(&self) -> Element {...}
      fn set_output(&mut self, output: Element) {...}
    }
  \end{minted}
  \caption{Parser code}
\end{figure}
\newpage
\section{Parser Logic}
Once, the program has read the source into memory, and the parser is instantiated the program begins a loop that will run until the end of the source. This loop will contain the logic for parsing. Firstly the program checks if the line is empty or contains all whitespace, if does the program will simply ignore it. Jade is a line sensitive language, so elements can't continue onto the next line without the use of special characters, and their implementation is out of scope for this guide. A new blank element is created, and the parser reads in how many leading spaces on the line in order to determine hierarchy, the hierarchy is defined once every element has been parsed, for simplicity.

The program runs the the \textbf{take\_while}, with a closure, that evaluates based on whether the character is a ``\textit{.}'', ``\textit{\#}'', ``\textit{(}'' symbols, or if it is whitespace. The program then begins another while loop that continues until the end of the line. Matching for the symbols mentioning before, with ``\#'' meaning id, ``.'' meaning class, ``('' meaning attributes eg. ``(href=\textquotedbl{}\#\textquotedbl{} required=\textquotedbl{}true\textquotedbl{} style=\textquotedbl{}margin-top: 2px\textquotedbl{})'', and if we find any whitespace everything up to the end of the line will be parsed as plain-text. This continues iteratively until the source is depleted, and the tree of elements is created.