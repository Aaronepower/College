\section{Introduction}

A \compiler{}  is a compiler that converts source code into some other form of source code, as opposed to a traditional compiler which converts human readable source code into machine instructions. This has a wide variety of uses within different implementations. \acro{CMS} have templates to generate \acro{HTML} pages from special markup. Academics use \LaTeX{} to convert plain text into scientific documents, and reports. Their use in relation to this thesis was to create a templating language. This primarily means the development of a programming language that will convert it's source code into \acro{HTML} for use in Web applications. The  main purpose of \languageName{} is to create a templating language that Web developers can use so that they can have more modular, and scalable markup in their Web application.

While there is no definitive first templating language. Their popularity began around the late 1990's with the development of \acro{XSLT} in 1999 and included in a W3C recommendation document \cite{XSLT}. This was developed for transforming \acro{XML} documents into other formats. E.g. PDF's\cite{XSLTEx}. 
\newpage
One of the most popular modern templating languages for use within Web applications Mustache\cite{Mustache}. Mustache is a ``\textit{logic-less}'' templating language, meaning it has no explicit control flow statements ``\textit{if, else, for}''\cite{MustacheMan}. Everything is instead based on the object that is passed to the template. Mustache is not a \acro{HTML} specific templating language, meaning Mustache's syntax is completely independent from it and can be used in conjunction, with any other language. However this also results in the language being unable to make assumptions based on the language leading the syntax to be verbose. 

\begin{figure}[!hbtp]
    \small
    \setstretch{1.0}
    \begin{verbatim}
            A typical Mustache template:

                Hello {{name}}
                You have just won {{value}} dollars!
                {{#in_ca}}
                Well, {{taxed_value}} dollars, after taxes.
                {{/in_ca}}

            Given the following hash:

                {
                  "name": "Chris",
                  "value": 10000,
                  "taxed_value": 10000 - (10000 * 0.4),
                  "in_ca": true
                }

            Will produce the following:

                Hello Chris
                You have just won 10000 dollars!
                Well, 6000.0 dollars, after taxes.
    \end{verbatim}
    \caption{A Mustache Example, \cite{MustacheMan}}
    \label{fig:mustacheEx}
\end{figure}
\newpage
\section{Main features of \languageName{}}
From extensive research and examining templating languages in established server-side programming languages(\textit{PHP, C\#, .NET})\cite{WikiCompare}. Also examining templating languages that were made specifically for use with JavaScript which are generally much younger in their development than their traditional language equivalents\cite{JSCompare}.

After the involved phase of research the main feature identified as critical to \languageName{}'s development. Would be the to include inheritance and variables which is to mean that you can write parent markup files which have child markup files which when parsed will include the markup of the parent, that arbitrary \languageName{} files can be inserted into other \languageName{} files, and be able to have data injected within the template respectively. 

One feature that seems to be most absent, or lacking in strong support, in most templating languages is \acro{I18n} support. In the current day it seems that having poor I18n support is a huge weakness in a templating language for the global multilingual web. According to Alexa, Google.com's top five countries are as follows United States, India, Japan, Brazil, and Russia. Out of 5 of the top countries only one of those is an English speaking country, and only two of which are Latin based languages. It is important now more than ever to have strong support for other speaking languages.
\newpage
\section{Building a \compiler{}.}
Building \compiler{} is a difficult task. The two primary sources for understanding a \compiler{} will be Compilers Principles Techniques and Tools (2nd Edition) \cite{DragonBook} also known as \textit{``The Dragon Book''}, and Parsing Techniques - A Practical Guide (2nd Edition) \cite{ParseTech}. Since the project is for a \compiler{}, and not a traditional compiler, there is a lot within the sources that won't be used. For example, The Dragon Book has chapter's such as \textit{``Run-Time Environments''}, and \textit{``Machine-Independent Optimizations''} which don't relate as the output will be \acro{HTML}, and not Machine Code. The syntax, and the features of the language will need to be mostly finalised early within the project to prevent any sort of feature creep, or spending time and resources on changing the style of the language. These include aspects like whether to have natural templates, that are independent of the language. Have a much more verbose language similar to Mustache \cite{Mustache}, or to have a much more terse language, but have it only work for outputting \acro{HTML} files, like Jade \cite{Jade}. 

\section{Why Rust?}
There are many reasons that make Rust a great candidate for building a \compiler{}. Rust doesn't have a garbage collector unlike other languages such as Java, C\# or JavaScript. This reduces the runtime overhead of the program giving a significant performance boost, which is important for handling on request compilation of templates on a server. Rust's \textit{``char''} type is a Unicode scalar value, and all \textit{``String''}'s are guarnteed to be valid UTF-8, eliminating the need to handle this case manually, or through a third party. Rust can also handle non-Latin characters much more easily than languages without e.g. JavaScript. Which would be an important feature since the \languageName{} will have strong I18n support. Since Rust has such a minimal runtime, it has strong \acro{FFI} support, meaning the \compiler{} can be used in servers written in different languages, without requiring the compiler to be rewritten in that language, and keeping the performance gains from having it built in Rust.