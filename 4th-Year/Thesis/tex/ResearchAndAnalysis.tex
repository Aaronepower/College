\chapter{Background Research}
\section{Introduction}

A \compiler{}  is a compiler that converts source code into some other form of source code, as opposed to a traditional compiler which converts human readable source code into machine instructions. This has a wide array of uses within different implementations. CMS'(Content Management Systems) have templates that writers pass in their writing to format it into a HTML article on their Website. Academics use \LaTeX{} to convert plain text into scientific documents, and reports. Their use in this thesis is to create a templating language which is a programming language that will convert it's source code into HTML for use in Web applications. The purpose of \languageName{} is to create a templating language that Web developers can use to have more modular, and scalable markup in their Web application.

While there is no definitive first templating language. Their popularity began around the late 1990's with XSLT(Extensible Stylesheet Language Transformations) in 1999\cite{XSLT}. Which was designed for transforming XML(Extensible Markup Language) documents into other formats IE: PDF's\cite{XSLTEx}.
\newpage 

One of the most popular modern templating languages for use within Web applications is Mustache\cite{Mustache}. Mustache is a ``\textit{logic-less}'' templating language, meaning it has no explicit control flow statements \textit{if, else, for}\cite{MustacheMan}. Everything is instead based on the object that is passed to the template See Figure ~\ref{fig:mustacheEx}. So if the developer couldn't change the markup if someone's name started with A instead of B unless they add a key to the hash before they pass it to the Mustache templating engine. Mustache is not a HTML specific templating language. Meaning it's syntax is completely independent from it and can be used with anything. However this also means it as language can't use assumptions based on the language leading the syntax to be very verbose. 

\begin{figure}[ht!]
    \setstretch{1.0}
    \begin{verbatim}
        A typical Mustache template:

            Hello {{name}}
            You have just won {{value}} dollars!
            {{#in_ca}}
            Well, {{taxed_value}} dollars, after taxes.
            {{/in_ca}}

        Given the following hash:

            {
              "name": "Chris",
              "value": 10000,
              "taxed_value": 10000 - (10000 * 0.4),
              "in_ca": true
            }

        Will produce the following:

            Hello Chris
            You have just won 10000 dollars!
            Well, 6000.0 dollars, after taxes.
    \end{verbatim}
    \caption{A Mustache Example, taken from The Mustache Manual\cite{MustacheMan}}
    \label{fig:mustacheEx}
\end{figure}
\clearpage


\section{Advantages of a templating language in the Web.}
As the Web has advanced there has always been a need to be able to have the document delivered to the user to be able to be changed based on who, and how the document is being requested. The most popular way to do this currently is to serve the user a nearly blank HTML(HyperText Markup Language) document containing links to JavaScript files that once downloaded, and executed will fill the DOM(Document Object Model) with the data, and information based on the user's request. Prime examples of this is JavaScript frameworks like React. In which the standard is to have a HTML document with a single \textcolor{red}{<div>} element, and let React build the DOM once it can.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{figure}[ht!]
    \setstretch{1.0}
    \begin{verbatim}
        <!DOCTYPE html>
        <html>
          <head>
            <meta charset="UTF-8" />
            <title>Hello React!</title>
            <script src="build/react.js"></script>
            <script src="build/react-dom.js"></script>
            <script src="build/script.js"</script>
          </head>
          <body>
            <div id="example"></div>
          </body>
        </html>
    \end{verbatim}
    \caption{Standard React HTML index file}
\end{figure}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

This comes with problems. The content of the Web page is dependent on the JavaScript. While the JavaScript is being downloaded the user will only see a blank page. This problem becomes especially apparent when the user is on a mobile network, or has a slow connection. Studies have shown that 47\% of mobile users expect a site to load in less than two seconds, that 40\% of mobile users will abandon a site if it doesn't load in three seconds or less, and that 52\% of users said that a quick page load is important to site loyalty\cite{MobileLoad}. In large scale applications, and businesses JavaScript size quickly becomes a huge bottleneck in the load times of Websites\cite{VergeJS}.\newline

It is in this area in particular that the advantages of using a templating language is seen. With a templating language the content of the Web page can be sent in the initial HTML page, making the ``perceived'' load time of the Web page very quick. Giving the JavaScript more time download than if the user were to see a blank page.\newline

Having a templating language can also provide good separation between the data model of the language, and the design of the page. The designers, or client-side programmers who are formatting the Web page don't have to worry about how the server-side logic works, or write code that could change server's data-model in order to change the format of the Web page. 
\newpage
\section{Main features of \languageName{}}
From doing my own research and looking at the two comparisons of both templating languages in established server-side programming languages(\textit{PHP, C\#, .NET})\cite{WikiCompare}, and templating languages made specifically for use in Isomorphic JavaScript which are generally much younger in their development than their traditional language equivalents\cite{JSCompare}.

From looking at these languages I think the main features of \languageName{} is to first have inheritance, and includes, and variables which is to mean that you can write parent markup files which have child markup files which when parsed will include the markup of the parent, that arbitrary \languageName{} files can be inserted into other \languageName{} files, and be able to have data injected within the template respectively. 

One feature that seems to be most absent, or lacking in strong support in most the languages is I18n(\textit{Internationalization and localization}) support. In the modern Web it seems that having poor I18n support is a huge weakness in a templating language for the Web. According to Alexa estimates Google.com's top five countries are as follows United States, India, Japan, Brazil, and Russia. Out of 5 of the top countries only one of those is an English speaking country, and only two of which are Latin based languages. It is important now more than ever to have strong support for other speaking languages.
\newpage
\section{Building a \compiler{}.}
Building \compiler{} is a difficult task. The two primary sources for building a \compiler{} will be Compilers Principles Techniques and Tools (2nd Edition) also known as ``\textit{The Dragon Book}''\cite{DragonBook}, and Parsing Techniques - A Practical Guide (2nd Edition)\cite{ParseTech}. Since the project is for a \compiler{}, and not a traditional compiler, there is a lot within the sources that won't be used. For example The Dragon Book has chapter's such as ``Run-Time Environments'', and ``Machine-Independent Optimizations'' which don't relate as are output is HTML, and not Machine Code. The syntax, and the features of the language will need to be mostly finalised early within the project to prevent any sort of feature creep, or spending time, and resources on changing the style of the language. Especially aspects like whether to have natural templates, which are templates which are independent of the language, and have a much more verbose language similar to Mustache\cite{Mustache}, or to have a much more terse language, but have it only work for outputting HTML files, like Jade\cite{Jade}. 

\section{Why Rust?}
There are many reasons that make Rust an great candidate for building a \compiler{}. Rust doesn't have a garbage collector that other languages like Java, or JavaScript. This reduces the runtime overhead of the program giving a significant performance boost, which is important for doing on request compilation of templates on a server. Rust's \textcolor{blue}{char} type is a Unicode scalar value. Meaning Rust can handle non-Latin characters much more easily than languages without IE: JavaScript. Which would be an important feature since the \languageName{} will have strong I18n support. Since rust has such a minimal runtime, it has strong FFI(Foreign Function Interface) support, meaning the \compiler{} can be used in servers written in different languages, without requiring the compiler to be rewritten in that language, and keeping the performance gains from having it built in Rust. 


% \chapter{Requirements}
% \section{Requirements Analysis}
% The user(developer) should be able to pass in a file written in TBD, and optionally data stored in
% a key-value pairing. This data will then be passed to a \compiler{}, which will return a html
% file based on the file, and data to be passed back as the HTTP response.

% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \begin{figure}[ht!]
% \caption{Layout file}
% \begin{verbatim}
% doctype html
% html
%     head
%     title= title
%     meta(charset="utf-8")
%     meta(name="viewport" content="width=device-width, initial-scale=1.0")
%     meta(http-equiv="X-UA-Compatible" content="IE=edge,chrome=1")
%     link(rel='stylesheet', href='/stylesheets/normalize.css')
%     link(rel='stylesheet', href='/stylesheets/skeleton.css')
%     link(rel='stylesheet', href='/stylesheets/style.css')
%     script(type='text/javascript', src='/javascripts/jquery.min.js' defer)
%     script(type='text/javascript', src='/javascripts/script.js' defer)
%     body
%         block content
% \end{verbatim}
% \end{figure}
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \begin{figure}[ht!]
% \caption{Index file}
% \begin{verbatim}
% extends layout

% block content
%     h1 Hello World

%     p Lorem Ipsum...
% \end{verbatim}
% \end{figure}

% \begin{figure}[ht!]
%     \caption{Rendered file}
%     \begin{verbatim}
% <!DOCTYPE html>
% <html>
%     <head>
%         <title>Express</title>
%         <meta charset = "utf-8">
%         <meta name="viewport" content="width=device-width, initial-scale=1.0">
%         <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
%         <link rel="stylesheet" href="/stylesheets/normalize.css">
%         <link rel="stylesheet" href="/stylesheets/skeleton.css">
%         <link rel="stylesheet" href="/stylesheets/style.css">
%         <script type="text/javascript" src="/javascripts/jquery.min.js" defer>
%         </script>
%         <script type="text/javascript" src="/javascripts/script.js" defer>
%         </script>
%     </head>
%     <body>
%         <h1>Hello World</h1>
%         <p>Lorem ipsum...</p>
%     </body>
% </html>
%     \end{verbatim}
% \end{figure}
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% \clearpage

% \subsection{Technical Requirements}
% All the other technologies would be programmed in Rust, and directly interfaced 
% within a Rust program.

% \subsubsection{Rust} 
% A new programming language from Mozilla, released in May 15th, 2015.\cite{Rust}
% Rust is a systems level programming language. Meaning that Rust is run directly on top of the existing
% OS(Operating System), as opposed to languages like Java, or Ruby which is run on top of a VM(Virtual Machine).
% Rust is designed to \textit{combines low-level control over performance with high-level convenience
% and safety guarantees}\cite{Rust}.

% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \begin{figure}[ht!]
%     \caption{Fizz buzz in rust.}
%     \begin{verbatim}
%             fn main() {
%                 for i in 1..101 {
%                     match (i%3, i%5) {
%                         (0, 0) => println!("FizzBuzz"),
%                         (0, _) => println!("Fizz"),
%                         (_, 0) => println!("Buzz"),
%                         (_, _) => println!("{}", i),
%                     }
%                 }
%             }
%     \end{verbatim}
% \end{figure}
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% \subsubsection{Iron}
% A high level Web framework designed for making Web servers in Rust.\cite{Iron}
% Iron is designed to enable other users to create plugins for it. The end-goal would be to integrate
% the \compiler{} with Iron, so a user could easily integrate within the system, and start using the
% templating language with ease.

% \begin{figure}[ht!]
%     \caption{Hello world server using Iron.}
%     \begin{verbatim}
%             extern crate iron;

%             use iron::prelude::*;
%             use iron::status;

%             fn main() {
%                 fn hello_world(_: &mut Request) -> IronResult<Response> {
%                     Ok(Response::with((status::Ok, "Hello World!")))
%                 }

%                 Iron::new(hello_world).http("localhost:3000").unwrap();
%                 println!("On 3000");
%             }
%     \end{verbatim}
% \end{figure}


% \newpage

% \section{System Model}
% The system is mainly two parts, the actual Web server written in rust with Iron, and the \compiler{}, 
% which will be used as middleware with Iron. Middleware being defined as software that runs between
% handling the  requests, making it easier for the user, or providing new functionality, 
% like adding a templating language.


% As shown in TBD. After a request has been handled by the user, but before the response has been
% sent, the \compiler{} will parse the template file, and any file the template requires. Building an 
% AST(Abstract Syntax Tree), and creating a HTML file from the AST. As this is a \compiler{},
% the program doesn't need to worry about code optimisation, or typical code generation
% that a typical compiler would. The main work of the program,would be to do lexical analysis,
% Syntax analysis, and Semantic analysis, and generate the HTML source code if the source is correct,
% and provide effective, and clear errors if the source code is incorrect.

% \newpage


% \section{Feasibility}
% There are a lot of risks with making a \compiler{}. The most important first step is to have
% an iron-clad definition of the language it is transcompiling, as changes in the fundamental syntax
% can cause large sections of code to be rewritten, and could even require in the how the parsing of
% the syntax is done.


% Of course there is always the risk that when the project finishes that it won't have all
% features specified in the requirements document due to time constraints, but this can be handled with
% effective time management, and being able to do effective cost analysis such as how viable a feature
% may be, and how much value does it provide over how much time it will take.
